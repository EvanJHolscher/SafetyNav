var Se = Object.defineProperty;
var Re = (t, i, e) => i in t ? Se(t, i, { enumerable: !0, configurable: !0, writable: !0, value: e }) : t[i] = e;
var u = (t, i, e) => (Re(t, typeof i != "symbol" ? i + "" : i, e), e);
class Oe {
  constructor(i) {
    u(this, "map");
    u(this, "listeners", {});
    u(this, "oneTimeListeners", {});
    this.map = i;
  }
  fire(i) {
    var e, n;
    i.target = this.map, (e = this.listeners[i.type]) == null || e.forEach((r) => r(i)), (n = this.oneTimeListeners[i.type]) == null || n.forEach((r) => {
      var s, a;
      r(i);
      const o = (s = this.oneTimeListeners[i.type]) == null ? void 0 : s.indexOf(r);
      o && ~o && ((a = this.oneTimeListeners[i.type]) == null || a.splice(o, 1));
    });
  }
  /**
   * Registers an event listener.
   */
  on(i, e) {
    (this.listeners[i] = this.listeners[i] ?? []).push(e);
  }
  /**
   * Un-registers an event listener.
   */
  off(i, e) {
    var r, o;
    const n = (r = this.listeners[i]) == null ? void 0 : r.indexOf(e);
    ~n && ((o = this.listeners[i]) == null || o.splice(n, 1));
  }
  /**
   * Registers an event listener to be invoked only once.
   */
  once(i, e) {
    (this.oneTimeListeners[i] = this.oneTimeListeners[i] ?? []).push(e);
  }
}
class z {
  /**
   * @private
   */
  constructor(i, e, n) {
    u(this, "type");
    u(this, "target");
    u(this, "originalEvent");
    u(this, "data");
    this.type = i, this.originalEvent = e, this.data = n;
  }
}
class re {
  /**
   * @private
   */
  constructor(i, e, n) {
    u(this, "type");
    u(this, "target");
    u(this, "originalEvent");
    /**
     * The server's response.
     *
     * Only presents when it's the {@link MapLibreGlDirectionsEventType.fetchroutesend|`fetchroutesend`} event, but might
     * be `undefined` in case the request to fetch directions failed.
     *
     * @see http://project-osrm.org/docs/v5.24.0/api/#responses
     */
    u(this, "data");
    this.type = i, this.originalEvent = e, this.data = n;
  }
}
const xe = {
  api: "https://router.project-osrm.org/route/v1",
  profile: "driving",
  requestOptions: {},
  requestTimeout: null,
  // can't use Infinity here because of this: https://github.com/denysdovhan/wtfjs/issues/61#issuecomment-325321753
  makePostRequest: !1,
  sourceName: "maplibre-gl-directions",
  pointsScalingFactor: 1,
  linesScalingFactor: 1,
  sensitiveWaypointLayers: ["maplibre-gl-directions-waypoint", "maplibre-gl-directions-waypoint-casing"],
  sensitiveSnappointLayers: ["maplibre-gl-directions-snappoint", "maplibre-gl-directions-snappoint-casing"],
  sensitiveRoutelineLayers: ["maplibre-gl-directions-routeline", "maplibre-gl-directions-routeline-casing"],
  sensitiveAltRoutelineLayers: ["maplibre-gl-directions-alt-routeline", "maplibre-gl-directions-alt-routeline-casing"],
  dragThreshold: 10,
  refreshOnMove: !1,
  bearings: !1
};
function ke(t = 1, i = 1, e = "maplibre-gl-directions") {
  return [
    {
      id: `${e}-snapline`,
      type: "line",
      source: e,
      layout: {
        "line-cap": "round",
        "line-join": "round"
      },
      paint: {
        "line-dasharray": [3, 3],
        "line-color": "#34343f",
        "line-opacity": 0.65,
        "line-width": 3
      },
      filter: ["==", ["get", "type"], "SNAPLINE"]
    },
    {
      id: `${e}-alt-routeline-casing`,
      type: "line",
      source: e,
      layout: {
        "line-cap": "butt",
        "line-join": "round"
      },
      paint: {
        "line-color": "#9e91be",
        "line-opacity": 0.55,
        "line-width": [
          "interpolate",
          ["exponential", 1.5],
          ["zoom"],
          // on zoom levels 0-5 - 7px by default and 10px when highlighted
          0,
          // highlighted to default ratio (epsilon) = 10 / 7 ~= 1.42
          ["case", ["boolean", ["get", "highlight"], !1], 10 * i, 7 * i],
          5,
          ["case", ["boolean", ["get", "highlight"], !1], 10 * i, 7 * i],
          // exponentially grows on zoom levels 5-18 finally becoming 32px when highlighted
          18,
          // default = 32 / epsilon ~= 23
          ["case", ["boolean", ["get", "highlight"], !1], 32 * i, 23 * i]
        ]
      },
      filter: ["==", ["get", "route"], "ALT"]
    },
    {
      id: `${e}-alt-routeline`,
      type: "line",
      source: e,
      layout: {
        "line-cap": "butt",
        "line-join": "round"
      },
      paint: {
        "line-color": "#9e91be",
        "line-opacity": 0.85,
        "line-width": [
          "interpolate",
          ["exponential", 1.5],
          ["zoom"],
          // on zoom levels 0-5 - 4px smaller than the casing (2px on each side). 7 - 4 = 3.
          // Doesn't change when highlighted
          0,
          // feature to casing ratio (psi) = 3 / 7 ~= 0.42
          3 * i,
          5,
          3 * i,
          // exponentially grows on zoom levels 5-18 finally becoming psi times the casing
          18,
          // psi * 23  ~= 10
          10 * i
        ]
      },
      filter: ["==", ["get", "route"], "ALT"]
    },
    {
      id: `${e}-routeline-casing`,
      type: "line",
      source: e,
      layout: {
        "line-cap": "butt",
        "line-join": "round"
      },
      paint: {
        "line-color": [
          "interpolate-hcl",
          ["linear"],
          ["get", "congestion"],
          0,
          "#7b51f8",
          1,
          "#42c74c",
          100,
          "#d72359"
        ],
        "line-opacity": 0.55,
        "line-width": [
          // same as the alt-routeline-casing
          "interpolate",
          ["exponential", 1.5],
          ["zoom"],
          0,
          ["case", ["boolean", ["get", "highlight"], !1], 10 * i, 7 * i],
          5,
          ["case", ["boolean", ["get", "highlight"], !1], 10 * i, 7 * i],
          18,
          ["case", ["boolean", ["get", "highlight"], !1], 32 * i, 23 * i]
        ]
      },
      filter: ["==", ["get", "route"], "SELECTED"]
    },
    {
      id: `${e}-routeline`,
      type: "line",
      source: e,
      layout: {
        "line-cap": "butt",
        "line-join": "round"
      },
      paint: {
        "line-color": [
          "interpolate-hcl",
          ["linear"],
          ["get", "congestion"],
          0,
          "#7b51f8",
          1,
          "#42c74c",
          100,
          "#d72359"
        ],
        "line-opacity": 0.85,
        "line-width": [
          // same as alt-routeline
          "interpolate",
          ["exponential", 1.5],
          ["zoom"],
          0,
          3 * i,
          5,
          3 * i,
          18,
          10 * i
        ]
      },
      filter: ["==", ["get", "route"], "SELECTED"]
    },
    {
      id: `${e}-hoverpoint-casing`,
      type: "circle",
      source: e,
      paint: {
        "circle-radius": [
          // same as snappoint-casing, but without highlighting (since it's always highlighted while present on the map)
          "interpolate",
          ["exponential", 1.5],
          ["zoom"],
          0,
          14 * t,
          5,
          14 * t,
          18,
          33 * t
        ],
        "circle-color": "#30a856",
        "circle-opacity": 0.65
      },
      filter: ["==", ["get", "type"], "HOVERPOINT"]
    },
    {
      id: `${e}-hoverpoint`,
      type: "circle",
      source: e,
      paint: {
        "circle-radius": [
          // same as snappoint, but without highlighting (since it's always highlighted while present on the map)
          "interpolate",
          ["exponential", 1.5],
          ["zoom"],
          0,
          9 * t,
          5,
          9 * t,
          18,
          21 * t
        ],
        "circle-color": "#30a856"
      },
      filter: ["==", ["get", "type"], "HOVERPOINT"]
    },
    {
      id: `${e}-snappoint-casing`,
      type: "circle",
      source: e,
      paint: {
        "circle-radius": [
          "interpolate",
          ["exponential", 1.5],
          ["zoom"],
          // don't forget it's the radius! The visible value is diameter (which is 2x)
          // on zoom levels 0-5 should be 5px more than the routeline casing. 7 + 5 = 12.
          // When highlighted should be +2px more. 12 + 2 = 14
          0,
          // highlighted to default ratio (epsilon) = 14 / 12 ~= 1.16
          ["case", ["boolean", ["get", "highlight"], !1], 14 * t, 12 * t],
          5,
          ["case", ["boolean", ["get", "highlight"], !1], 14 * t, 12 * t],
          // exponentially grows on zoom levels 5-18 finally becoming the same 5px wider than the routeline's casing on
          // the same zoom level: 23 + 5 = 28px
          18,
          // highlighted = default ~= 33
          ["case", ["boolean", ["get", "highlight"], !1], 33 * t, 28 * t]
        ],
        "circle-color": ["case", ["boolean", ["get", "highlight"], !1], "#e50d3f", "#cb3373"],
        "circle-opacity": 0.65
      },
      filter: ["==", ["get", "type"], "SNAPPOINT"]
    },
    {
      id: `${e}-snappoint`,
      type: "circle",
      source: e,
      paint: {
        "circle-radius": [
          "interpolate",
          ["exponential", 1.5],
          ["zoom"],
          // on zoom levels 0-5 - 5px smaller than the casing. 12 - 5 = 7.
          0,
          // feature to casing ratio (psi) = 7 / 12 ~= 0.58
          // highlighted to default ratio (epsilon) = 9 / 7 ~= 1.28
          ["case", ["boolean", ["get", "highlight"], !1], 9 * t, 7 * t],
          5,
          ["case", ["boolean", ["get", "highlight"], !1], 9 * t, 7 * t],
          // exponentially grows on zoom levels 5-18 finally becoming psi times the casing
          18,
          // psi * 28 ~= 16
          // when highlighted multiply by epsilon ~= 21
          ["case", ["boolean", ["get", "highlight"], !1], 21 * t, 16 * t]
        ],
        "circle-color": ["case", ["boolean", ["get", "highlight"], !1], "#e50d3f", "#cb3373"]
      },
      filter: ["==", ["get", "type"], "SNAPPOINT"]
    },
    {
      id: `${e}-waypoint-casing`,
      type: "circle",
      source: e,
      paint: {
        "circle-radius": [
          // same as snappoint-casing
          "interpolate",
          ["exponential", 1.5],
          ["zoom"],
          0,
          ["case", ["boolean", ["get", "highlight"], !1], 14 * t, 12 * t],
          5,
          ["case", ["boolean", ["get", "highlight"], !1], 14 * t, 12 * t],
          18,
          ["case", ["boolean", ["get", "highlight"], !1], 33 * t, 28 * t]
        ],
        "circle-color": ["case", ["boolean", ["get", "highlight"], !1], "#6d26d7", "#7b33e7"],
        "circle-opacity": 0.65
      },
      filter: ["==", ["get", "type"], "WAYPOINT"]
    },
    {
      id: `${e}-waypoint`,
      type: "circle",
      source: e,
      paint: {
        // same as snappoint
        "circle-radius": [
          "interpolate",
          ["exponential", 1.5],
          ["zoom"],
          0,
          ["case", ["boolean", ["get", "highlight"], !1], 9 * t, 7 * t],
          5,
          ["case", ["boolean", ["get", "highlight"], !1], 9 * t, 7 * t],
          18,
          ["case", ["boolean", ["get", "highlight"], !1], 21 * t, 16 * t]
        ],
        "circle-color": ["case", ["boolean", ["get", "highlight"], !1], "#6d26d7", "#7b33e7"]
      },
      filter: ["==", ["get", "type"], "WAYPOINT"]
    }
    // TODO try to remove when MapLibre's updated
  ];
}
let ue = (t = 21) => crypto.getRandomValues(new Uint8Array(t)).reduce((i, e) => (e &= 63, e < 36 ? i += e.toString(36) : e < 62 ? i += (e - 26).toString(36).toUpperCase() : e > 62 ? i += "-" : i += "_", i), "");
var fe = { exports: {} };
(function(t) {
  var i = {};
  function e(o) {
    return Math.floor(Math.abs(o) + 0.5) * (o >= 0 ? 1 : -1);
  }
  function n(o, s, a) {
    o = e(o * a), s = e(s * a);
    var l = (o - s) * 2;
    l < 0 && (l = -l - 1);
    for (var d = ""; l >= 32; )
      d += String.fromCharCode((32 | l & 31) + 63), l /= 32;
    return d += String.fromCharCode((l | 0) + 63), d;
  }
  i.decode = function(o, s) {
    for (var a = 0, l = 0, d = 0, c = [], p = 0, g = 0, m = null, f, D, E = Math.pow(10, Number.isInteger(s) ? s : 5); a < o.length; ) {
      m = null, p = 1, g = 0;
      do
        m = o.charCodeAt(a++) - 63, g += (m & 31) * p, p *= 32;
      while (m >= 32);
      f = g & 1 ? (-g - 1) / 2 : g / 2, p = 1, g = 0;
      do
        m = o.charCodeAt(a++) - 63, g += (m & 31) * p, p *= 32;
      while (m >= 32);
      D = g & 1 ? (-g - 1) / 2 : g / 2, l += f, d += D, c.push([l / E, d / E]);
    }
    return c;
  }, i.encode = function(o, s) {
    if (!o.length)
      return "";
    for (var a = Math.pow(10, Number.isInteger(s) ? s : 5), l = n(o[0][0], 0, a) + n(o[0][1], 0, a), d = 1; d < o.length; d++) {
      var c = o[d], p = o[d - 1];
      l += n(c[0], p[0], a), l += n(c[1], p[1], a);
    }
    return l;
  };
  function r(o) {
    for (var s = [], a = 0; a < o.length; a++) {
      var l = o[a].slice();
      s.push([l[1], l[0]]);
    }
    return s;
  }
  i.fromGeoJSON = function(o, s) {
    if (o && o.type === "Feature" && (o = o.geometry), !o || o.type !== "LineString")
      throw new Error("Input must be a GeoJSON LineString");
    return i.encode(r(o.coordinates), s);
  }, i.toGeoJSON = function(o, s) {
    var a = i.decode(o, s);
    return {
      type: "LineString",
      coordinates: r(a)
    };
  }, t.exports && (t.exports = i);
})(fe);
var ae = fe.exports;
function He(t, i) {
  return t.geometries === "geojson" ? i.coordinates : t.geometries === "polyline6" ? ae.decode(i, 6).map((e) => e.reverse()) : ae.decode(i, 5).map((e) => e.reverse());
}
function Be(t, i, e) {
  var n, r, o, s;
  if ((n = t.annotations) != null && n.includes("congestion_numeric"))
    return ((r = i == null ? void 0 : i.congestion_numeric) == null ? void 0 : r[e]) ?? 0;
  if ((o = t.annotations) != null && o.includes("congestion"))
    switch (((s = i == null ? void 0 : i.congestion) == null ? void 0 : s[e]) ?? "") {
      case "unknown":
        return 0;
      case "low":
        return 1;
      case "moderate":
        return 34;
      case "heavy":
        return 77;
      case "severe":
        return 100;
      default:
        return 0;
    }
  else
    return 0;
}
function We(t, i, e) {
  return !t.geometries || t.geometries === "polyline" ? Math.abs(i[0] - e[0]) <= 1e-5 && Math.abs(i[1] - e[1]) <= 1e-5 : i[0] === e[0] && i[1] === e[1];
}
function me(t) {
  const i = ke(
    t == null ? void 0 : t.pointsScalingFactor,
    t == null ? void 0 : t.linesScalingFactor,
    t == null ? void 0 : t.sourceName
  );
  return Object.assign({}, xe, { layers: i }, t);
}
function ye(t, i, e) {
  const n = t.makePostRequest ? "post" : "get";
  let r, o;
  if (n === "get")
    r = `${t.api}/${t.profile}/${i.join(";")}`, o = new URLSearchParams(t.requestOptions);
  else {
    r = `${t.api}/${t.profile}${t.requestOptions.access_token ? `?access_token=${t.requestOptions.access_token}` : ""}`;
    const s = new FormData();
    Object.entries(t.requestOptions).forEach(([a, l]) => {
      a !== "access_token" && s.set(a, l);
    }), s.set("coordinates", i.join(";")), o = new URLSearchParams(s);
  }
  return t.bearings && o.set(
    "bearings",
    e.map((s) => s ? `${s[0]},${s[1]}` : "").join(";")
  ), {
    method: n,
    url: r,
    payload: o
  };
}
function ve(t, i, e) {
  return {
    type: "Feature",
    geometry: {
      type: "Point",
      coordinates: t
    },
    properties: {
      type: i,
      id: ue(),
      ...e ?? {}
    }
  };
}
function be(t, i, e, n, r = !1) {
  if (t.length !== i.length)
    return [];
  const o = t.map((s, a) => ({
    type: "Feature",
    geometry: {
      type: "LineString",
      coordinates: [
        [s[0], s[1]],
        [i[a][0], i[a][1]]
      ]
    },
    properties: {
      type: "SNAPLINE"
    }
  }));
  return ~n && e !== void 0 && r && (o.push({
    type: "Feature",
    geometry: {
      type: "LineString",
      coordinates: [
        [e[0], e[1]],
        [i[n][0], i[n][1]]
      ]
    },
    properties: {
      type: "SNAPLINE"
    }
  }), o.push({
    type: "Feature",
    geometry: {
      type: "LineString",
      coordinates: [
        [e[0], e[1]],
        [i[n + 1][0], i[n + 1][1]]
      ]
    },
    properties: {
      type: "SNAPLINE"
    }
  })), o;
}
function _e(t, i, e, n) {
  return i.map((r, o) => {
    const s = He(t, r.geometry), a = n.map((m) => m.geometry.coordinates);
    let l = 0;
    const d = a.map((m) => {
      const f = s.slice(l).findIndex((D) => We(t, D, m));
      return f !== -1 && (l += f), l;
    }).slice(1);
    let c = 0;
    const p = d.map((m) => s.slice(c, c = m + 1)), g = [];
    return p.forEach((m, f) => {
      const D = ue();
      m.forEach((E, w) => {
        var b, P, T;
        const v = g[g.length - 1], y = Be(t, (b = r.legs[f]) == null ? void 0 : b.annotation, w);
        if (f === ((P = v == null ? void 0 : v.properties) == null ? void 0 : P.legIndex) && ((T = v.properties) == null ? void 0 : T.congestion) === y)
          v.geometry.coordinates.push(E);
        else {
          const A = n[f].properties ?? {}, H = n[f + 1].properties ?? {}, S = {
            type: "Feature",
            geometry: {
              type: "LineString",
              coordinates: []
            },
            properties: {
              id: D,
              // used to highlight the whole leg when hovered, not a single segment
              routeIndex: o,
              // used to switch between alternative and selected routes
              route: o === e ? "SELECTED" : "ALT",
              legIndex: f,
              // used across forEach iterations to check whether it's safe to continue a segment
              congestion: y,
              // the current segment's congestion level
              departSnappointProperties: A,
              // include depart and arrive snappoints' properties to allow customization...
              arriveSnappointProperties: H
              // ...of behavior via a subclass
            }
          };
          v && S.geometry.coordinates.push(
            v.geometry.coordinates[v.geometry.coordinates.length - 1]
          ), S.geometry.coordinates.push(E), g.push(S);
        }
      });
    }), g;
  });
}
const ct = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  buildConfiguration: me,
  buildPoint: ve,
  buildRequest: ye,
  buildRoutelines: _e,
  buildSnaplines: be
}, Symbol.toStringTag, { value: "Module" }));
class gt extends Oe {
  constructor(e, n) {
    super(e);
    u(this, "configuration");
    u(this, "_interactive", !1);
    u(this, "buildRequest", ye);
    u(this, "buildPoint", ve);
    u(this, "buildSnaplines", be);
    u(this, "buildRoutelines", _e);
    u(this, "onMoveHandler");
    u(this, "onDragDownHandler");
    u(this, "onDragMoveHandler");
    u(this, "onDragUpHandler");
    u(this, "onClickHandler");
    u(this, "liveRefreshHandler");
    u(this, "_waypoints", []);
    u(this, "snappoints", []);
    u(this, "routelines", []);
    u(this, "selectedRouteIndex", 0);
    u(this, "hoverpoint");
    u(this, "highlightedWaypoints", []);
    u(this, "highlightedSnappoints", []);
    u(this, "dragDownPosition", {
      x: 0,
      y: 0
    });
    u(this, "waypointBeingDragged");
    u(this, "waypointBeingDraggedInitialCoordinates");
    u(this, "departSnappointIndex", -1);
    u(this, "currentMousePosition", {
      x: 0,
      y: 0
    });
    u(this, "refreshOnMoveIsRefreshing", !1);
    u(this, "noMouseMovementTimer");
    u(this, "lastRequestMousePosition", {
      x: 0,
      y: 0
    });
    /**
     * A publicly-available abort-controller that allows to manually abort an ongoing routing-request.
     *
     * Only exists (`!== undefined`) when there's an ongoing routing-request.
     *
     * @example
     * ```
     * direсtions.abortController.abort();
     * ```
     */
    u(this, "abortController");
    this.map = e, this.configuration = me(n), this.onMoveHandler = this.onMove.bind(this), this.onDragDownHandler = this.onDragDown.bind(this), this.onDragMoveHandler = this.onDragMove.bind(this), this.onDragUpHandler = this.onDragUp.bind(this), this.onClickHandler = this.onClick.bind(this), this.liveRefreshHandler = this.liveRefresh.bind(this), this.init();
  }
  /**
   * @alias {@link waypoints}
   *
   * Aliased for the sakes of naming-consistency.
   */
  get waypointsCoordinates() {
    return this._waypoints.map((e) => [e.geometry.coordinates[0], e.geometry.coordinates[1]]);
  }
  get snappointsCoordinates() {
    return this.snappoints.map((e) => [e.geometry.coordinates[0], e.geometry.coordinates[1]]);
  }
  get snaplines() {
    var e, n, r;
    return this.buildSnaplines(
      this.waypointsCoordinates,
      this.snappointsCoordinates,
      (e = this.hoverpoint) == null ? void 0 : e.geometry.coordinates,
      this.departSnappointIndex,
      (r = (n = this.hoverpoint) == null ? void 0 : n.properties) == null ? void 0 : r.showSnaplines
    );
  }
  init() {
    this.map.addSource(this.configuration.sourceName, {
      type: "geojson",
      data: {
        type: "FeatureCollection",
        features: []
      }
    }), this.configuration.layers.forEach((e) => {
      this.map.addLayer(e);
    });
  }
  async fetchDirections(e) {
    var r, o;
    (r = this.abortController) == null || r.abort();
    const n = this.interactive;
    if (this._waypoints.length >= 2) {
      this.fire(new re("fetchroutesstart", e)), this.abortController = new AbortController();
      const s = this.abortController.signal;
      s.onabort = () => {
        this.interactive = n;
      }, this.interactive = !1;
      let a;
      this.configuration.requestTimeout !== null && (a = setTimeout(() => {
        var g;
        return (g = this.abortController) == null ? void 0 : g.abort();
      }, this.configuration.requestTimeout));
      const { method: l, url: d, payload: c } = this.buildRequest(
        this.configuration,
        this.waypointsCoordinates,
        this.configuration.bearings ? this.waypointsBearings : void 0
      );
      let p;
      try {
        if (l === "get" ? p = await (await fetch(`${d}?${c}`, { signal: this.abortController.signal })).json() : p = await (await fetch(`${d}`, {
          signal: this.abortController.signal,
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          body: c
        })).json(), p.code !== "Ok")
          throw new Error(p.message ?? "An unexpected error occurred.");
      } finally {
        ((o = this.abortController) == null ? void 0 : o.signal.reason) !== "DESTROY" && (this.interactive = n), this.abortController = void 0, clearTimeout(a), this.fire(new re("fetchroutesend", e, p));
      }
      this.snappoints = p.waypoints.map(
        (g, m) => {
          var f;
          return this.buildPoint(g.location, "SNAPPOINT", {
            waypointProperties: ((f = this._waypoints[m]) == null ? void 0 : f.properties) ?? {}
          });
        }
      ), this.routelines = this.buildRoutelines(
        this.configuration.requestOptions,
        p.routes,
        this.selectedRouteIndex,
        this.snappoints
      ), p.routes.length <= this.selectedRouteIndex && (this.selectedRouteIndex = 0);
    } else
      this.snappoints = [], this.routelines = [];
    this.draw(!1);
  }
  draw(e = !0) {
    const n = [
      ...this._waypoints,
      ...this.snappoints,
      ...this.snaplines,
      ...this.routelines.reduce((o, s) => e ? o.concat(...s) : o.concat(
        ...s.map((a) => (a.properties && (a.properties.route = a.properties.routeIndex === this.selectedRouteIndex ? "SELECTED" : "ALT"), a))
      ), [])
    ];
    this.hoverpoint && n.push(this.hoverpoint);
    const r = {
      type: "FeatureCollection",
      features: n
    };
    this.map.getSource(this.configuration.sourceName) && this.map.getSource(this.configuration.sourceName).setData(r);
  }
  deHighlight() {
    this.highlightedWaypoints.forEach((e) => {
      e != null && e.properties && (e.properties.highlight = !1);
    }), this.highlightedSnappoints.forEach((e) => {
      e != null && e.properties && (e.properties.highlight = !1);
    }), this.routelines.forEach((e) => {
      e.forEach((n) => {
        n.properties && (n.properties.highlight = !1);
      });
    });
  }
  onMove(e) {
    var r, o, s, a;
    const n = this.map.queryRenderedFeatures(e.point, {
      layers: [
        ...this.configuration.sensitiveWaypointLayers,
        ...this.configuration.sensitiveSnappointLayers,
        ...this.configuration.sensitiveRoutelineLayers,
        ...this.configuration.sensitiveAltRoutelineLayers
      ]
    })[0];
    if (this.deHighlight(), this.configuration.sensitiveWaypointLayers.includes((n == null ? void 0 : n.layer.id) ?? "")) {
      this.map.getCanvas().style.cursor = "pointer", this.map.dragPan.disable();
      const l = this._waypoints.findIndex((d) => {
        var c, p;
        return ((c = d.properties) == null ? void 0 : c.id) === ((p = n == null ? void 0 : n.properties) == null ? void 0 : p.id);
      });
      this.highlightedWaypoints = [this._waypoints[l]], this.highlightedSnappoints = [this.snappoints[l]], (r = this.highlightedWaypoints[0]) != null && r.properties && (this.highlightedWaypoints[0].properties.highlight = !0), (o = this.highlightedSnappoints[0]) != null && o.properties && (this.highlightedSnappoints[0].properties.highlight = !0), this.hoverpoint && (this.hoverpoint = void 0);
    } else if (this.configuration.sensitiveSnappointLayers.includes((n == null ? void 0 : n.layer.id) ?? "")) {
      this.map.getCanvas().style.cursor = "pointer";
      const l = this.snappoints.findIndex((d) => {
        var c, p;
        return ((c = d.properties) == null ? void 0 : c.id) === ((p = n == null ? void 0 : n.properties) == null ? void 0 : p.id);
      });
      this.highlightedSnappoints = [this.snappoints[l]], this.highlightedWaypoints = [this._waypoints[l]], this.highlightedSnappoints[0].properties && (this.highlightedSnappoints[0].properties.highlight = !0), this.highlightedWaypoints[0].properties && (this.highlightedWaypoints[0].properties.highlight = !0), this.hoverpoint && (this.hoverpoint = void 0);
    } else
      this.configuration.sensitiveRoutelineLayers.includes((n == null ? void 0 : n.layer.id) ?? "") ? (this.map.getCanvas().style.cursor = "pointer", this.map.dragPan.disable(), this.hoverpoint ? this.hoverpoint.geometry.coordinates = [e.lngLat.lng, e.lngLat.lat] : this.hoverpoint = this.buildPoint([e.lngLat.lng, e.lngLat.lat], "HOVERPOINT", {
        departSnappointProperties: {
          ...JSON.parse(((s = n == null ? void 0 : n.properties) == null ? void 0 : s.departSnappointProperties) ?? "{}")
        },
        arriveSnappointProperties: {
          ...JSON.parse(((a = n == null ? void 0 : n.properties) == null ? void 0 : a.arriveSnappointProperties) ?? "{}")
        }
      }), this.routelines.forEach((l) => {
        l.forEach((d) => {
          var c, p;
          d.properties && ((c = d.properties) == null ? void 0 : c.id) === ((p = n == null ? void 0 : n.properties) == null ? void 0 : p.id) && (d.properties.highlight = !0);
        });
      })) : this.configuration.sensitiveAltRoutelineLayers.includes((n == null ? void 0 : n.layer.id) ?? "") ? (this.map.getCanvas().style.cursor = "pointer", this.routelines.forEach((l) => {
        l.forEach((d) => {
          var c, p;
          d.properties && ((c = d.properties) == null ? void 0 : c.id) === ((p = n == null ? void 0 : n.properties) == null ? void 0 : p.id) && (d.properties.highlight = !0);
        });
      }), this.hoverpoint && (this.hoverpoint = void 0)) : (this.map.dragPan.enable(), this.map.getCanvas().style.cursor = "", this.hoverpoint = void 0);
    this.draw();
  }
  onDragDown(e) {
    var r, o, s, a, l, d;
    if (e.type === "touchstart" && e.originalEvent.touches.length !== 1 || e.type === "mousedown" && e.originalEvent.which !== 1)
      return;
    const n = this.map.queryRenderedFeatures(e.point);
    if (n.length && n[0].source === this.configuration.sourceName) {
      const c = n.filter((p) => this.configuration.sensitiveWaypointLayers.includes((p == null ? void 0 : p.layer.id) ?? "") || this.configuration.sensitiveSnappointLayers.includes((p == null ? void 0 : p.layer.id) ?? "") || this.configuration.sensitiveRoutelineLayers.includes((p == null ? void 0 : p.layer.id) ?? ""))[0];
      if (this.dragDownPosition = e.point, this.currentMousePosition = e.point, this.configuration.sensitiveWaypointLayers.includes((c == null ? void 0 : c.layer.id) ?? ""))
        this.waypointBeingDragged = this._waypoints.find((p) => {
          var g, m;
          return ((g = p.properties) == null ? void 0 : g.id) === ((m = c == null ? void 0 : c.properties) == null ? void 0 : m.id);
        }), this.waypointBeingDraggedInitialCoordinates = (r = this.waypointBeingDragged) == null ? void 0 : r.geometry.coordinates;
      else if (this.configuration.sensitiveRoutelineLayers.includes((c == null ? void 0 : c.layer.id) ?? "")) {
        if (this.departSnappointIndex = JSON.parse((o = c == null ? void 0 : c.properties) == null ? void 0 : o.legIndex), this.hoverpoint)
          if (this.configuration.refreshOnMove) {
            const p = this.departSnappointIndex !== void 0 ? this.departSnappointIndex + 1 : void 0;
            this._addWaypoint([e.lngLat.lng, e.lngLat.lat], p, e), this.waypointBeingDragged = this._waypoints[p], this.hoverpoint = void 0;
          } else
            this.hoverpoint.geometry.coordinates = [e.lngLat.lng, e.lngLat.lat];
        else
          this.hoverpoint = this.buildPoint([e.lngLat.lng, e.lngLat.lat], "HOVERPOINT", {
            departSnappointProperties: {
              ...JSON.parse(((s = c == null ? void 0 : c.properties) == null ? void 0 : s.departSnappointProperties) ?? "{}")
            },
            arriveSnappointProperties: {
              ...JSON.parse(((a = c == null ? void 0 : c.properties) == null ? void 0 : a.arriveSnappointProperties) ?? "{}")
            }
          });
        (l = this.hoverpoint) != null && l.properties && (this.hoverpoint.properties.showSnaplines = !0), ~this.departSnappointIndex && ((d = this.snappoints[this.departSnappointIndex]) != null && d.properties) && (this.snappoints[this.departSnappointIndex].properties.highlight = !0, this.highlightedSnappoints.push(this.snappoints[this.departSnappointIndex]), this.snappoints[this.departSnappointIndex + 1].properties.highlight = !0, this.highlightedSnappoints.push(this.snappoints[this.departSnappointIndex + 1]));
      }
      this.map.off("touchstart", this.onMoveHandler), this.map.off("mousemove", this.onMoveHandler), e.type === "touchstart" ? (this.map.on("touchmove", this.onDragMoveHandler), this.map.on("touchend", this.onDragUpHandler)) : e.type === "mousedown" && (this.map.on("mousemove", this.onDragMoveHandler), this.map.on("mouseup", this.onDragUpHandler)), this.draw();
    }
  }
  onDragMove(e) {
    if (this.configuration.refreshOnMove && (clearTimeout(this.noMouseMovementTimer), this.noMouseMovementTimer = setTimeout(this.liveRefreshHandler, 300, e)), e.type === "touchmove" && e.originalEvent.touches.length !== 1)
      return e.originalEvent.preventDefault();
    e.type === "mousemove" && e.originalEvent.which !== 1 || (this.waypointBeingDragged ? this.waypointBeingDragged.geometry.coordinates = [e.lngLat.lng, e.lngLat.lat] : this.hoverpoint && (this.hoverpoint.geometry.coordinates = [e.lngLat.lng, e.lngLat.lat]), this.currentMousePosition = e.point, this.draw(), this.configuration.refreshOnMove && !this.refreshOnMoveIsRefreshing && this.liveRefreshHandler(e));
  }
  async onDragUp(e) {
    var n, r, o;
    if (this.configuration.refreshOnMove && clearTimeout(this.noMouseMovementTimer), !(e.type === "mouseup" && e.originalEvent.which !== 1)) {
      if ((n = this.hoverpoint) != null && n.properties && (this.hoverpoint.properties.showSnaplines = !1), Math.abs(e.point.x - ((r = this.dragDownPosition) == null ? void 0 : r.x)) > (this.configuration.dragThreshold >= 0 ? this.configuration.dragThreshold : 0) || Math.abs(e.point.y - ((o = this.dragDownPosition) == null ? void 0 : o.y)) > (this.configuration.dragThreshold >= 0 ? this.configuration.dragThreshold : 0))
        if (this.waypointBeingDragged) {
          this.waypointBeingDragged.geometry.coordinates = [e.lngLat.lng, e.lngLat.lat];
          const s = new z("movewaypoint", e, {
            index: this._waypoints.indexOf(this.waypointBeingDragged),
            initialCoordinates: this.waypointBeingDraggedInitialCoordinates
          });
          this.fire(s);
          try {
            await this.fetchDirections(s);
          } catch (a) {
            a instanceof DOMException && a.name == "AbortError" || this.waypointBeingDraggedInitialCoordinates && (this.waypointBeingDragged.geometry.coordinates = this.waypointBeingDraggedInitialCoordinates);
          }
          this.waypointBeingDragged = void 0, this.waypointBeingDraggedInitialCoordinates = void 0;
        } else
          this.hoverpoint && (this._addWaypoint(
            [e.lngLat.lng, e.lngLat.lat],
            this.departSnappointIndex !== void 0 ? this.departSnappointIndex + 1 : void 0,
            e
          ), this.hoverpoint = void 0);
      else
        this.waypointBeingDragged && this.waypointBeingDraggedInitialCoordinates ? (this.waypointBeingDragged.geometry.coordinates = this.waypointBeingDraggedInitialCoordinates, this.waypointBeingDragged = void 0, this.waypointBeingDraggedInitialCoordinates = void 0) : this.hoverpoint && (this.hoverpoint = void 0);
      this.deHighlight(), e.type === "touchend" ? (this.map.off("touchmove", this.onDragMoveHandler), this.map.off("touchend", this.onDragUpHandler)) : e.type === "mouseup" && (this.map.off("mousemove", this.onDragMoveHandler), this.map.off("mouseup", this.onDragUpHandler)), this.map.on("touchstart", this.onMoveHandler), this.map.on("mousemove", this.onMoveHandler), this.map.dragPan.enable(), this.draw();
    }
  }
  async liveRefresh(e) {
    var n, r, o, s;
    if (Math.abs(((n = this.lastRequestMousePosition) == null ? void 0 : n.x) - ((r = this.currentMousePosition) == null ? void 0 : r.x)) > (this.configuration.dragThreshold >= 0 ? this.configuration.dragThreshold : 0) || Math.abs(((o = this.lastRequestMousePosition) == null ? void 0 : o.y) - ((s = this.currentMousePosition) == null ? void 0 : s.y)) > (this.configuration.dragThreshold >= 0 ? this.configuration.dragThreshold : 0)) {
      if (this.refreshOnMoveIsRefreshing = !0, this.lastRequestMousePosition = this.currentMousePosition, this.waypointBeingDragged) {
        const a = new z("movewaypoint", e, {
          index: this._waypoints.indexOf(this.waypointBeingDragged),
          initialCoordinates: this.waypointBeingDraggedInitialCoordinates
        });
        this.fire(a);
        try {
          await this.fetchDirections(a);
        } catch {
        }
      }
      this.refreshOnMoveIsRefreshing = !1;
    }
  }
  onClick(e) {
    const n = this.map.queryRenderedFeatures(e.point, {
      layers: [
        ...this.configuration.sensitiveWaypointLayers,
        ...this.configuration.sensitiveSnappointLayers,
        ...this.configuration.sensitiveAltRoutelineLayers,
        ...this.configuration.sensitiveRoutelineLayers
      ]
    })[0];
    if (this.configuration.sensitiveWaypointLayers.includes((n == null ? void 0 : n.layer.id) ?? "")) {
      const r = this._waypoints.findIndex((o) => {
        var s, a;
        return ((s = o.properties) == null ? void 0 : s.id) === ((a = n == null ? void 0 : n.properties) == null ? void 0 : a.id);
      });
      ~r && this._removeWaypoint(r, e);
    } else if (this.configuration.sensitiveSnappointLayers.includes((n == null ? void 0 : n.layer.id) ?? "")) {
      const r = this.snappoints.findIndex((o) => {
        var s, a;
        return ((s = o.properties) == null ? void 0 : s.id) === ((a = n == null ? void 0 : n.properties) == null ? void 0 : a.id);
      });
      ~r && this._removeWaypoint(r, e);
    } else
      this.configuration.sensitiveAltRoutelineLayers.includes((n == null ? void 0 : n.layer.id) ?? "") ? this.selectedRouteIndex = this.routelines.findIndex((r) => !!r.find((o) => {
        var s, a;
        return ((s = o.properties) == null ? void 0 : s.id) === ((a = n == null ? void 0 : n.properties) == null ? void 0 : a.id);
      })) : this.configuration.sensitiveRoutelineLayers.includes((n == null ? void 0 : n.layer.id) ?? "") || this._addWaypoint([e.lngLat.lng, e.lngLat.lat], void 0, e);
    this.draw(!1);
  }
  assignWaypointsCategories() {
    this._waypoints.forEach((e, n) => {
      const r = n === 0 ? "ORIGIN" : n === this._waypoints.length - 1 ? "DESTINATION" : void 0;
      e.properties && (e.properties.index = n, e.properties.category = r);
    });
  }
  async _addWaypoint(e, n, r) {
    var s;
    (s = this.abortController) == null || s.abort(), n = n ?? this._waypoints.length, this._waypoints.splice(
      n,
      0,
      this.buildPoint(
        e,
        "WAYPOINT",
        this.configuration.bearings ? {
          bearing: void 0
        } : void 0
      )
    ), this.assignWaypointsCategories();
    const o = new z("addwaypoint", r, {
      index: n
    });
    this.fire(o), this.draw();
    try {
      await this.fetchDirections(o);
    } catch {
    }
  }
  async _removeWaypoint(e, n) {
    var o;
    (o = this.abortController) == null || o.abort(), this._waypoints.splice(e, 1), this.snappoints.splice(e, 1), this.assignWaypointsCategories();
    const r = new z("removewaypoint", n, {
      index: e
    });
    this.fire(r), this.draw();
    try {
      await this.fetchDirections(r);
    } catch {
    }
  }
  // the public interface begins here
  /**
   * The interactivity state of the instance. When `true`, the user is allowed to interact with the features drawn on
   * the map and to add waypoints by clicking the map. Automatically set to `false` whenever there's an ongoing
   * routing request.
   */
  get interactive() {
    return this._interactive;
  }
  set interactive(e) {
    this._interactive = e, e ? (this.map.on("touchstart", this.onMoveHandler), this.map.on("touchstart", this.onDragDownHandler), this.map.on("mousemove", this.onMoveHandler), this.map.on("mousedown", this.onDragDownHandler), this.map.on("click", this.onClickHandler)) : (this.map.off("touchstart", this.onMoveHandler), this.map.off("touchstart", this.onDragDownHandler), this.map.off("mousemove", this.onMoveHandler), this.map.off("mousedown", this.onDragDownHandler), this.map.off("click", this.onClickHandler));
  }
  /**
   * Returns all the waypoints' coordinates in the order they appear.
   */
  get waypoints() {
    return this.waypointsCoordinates;
  }
  /**
   * @alias Synchronous analogue of {@link setWaypoints}.
   */
  set waypoints(e) {
    this.setWaypoints(e);
  }
  /**
   * Returns all the waypoints' bearings values or an empty array if the `bearings` configuration option is not
   * enabled.
   */
  get waypointsBearings() {
    return this.configuration.bearings ? this._waypoints.map((e) => Array.isArray(e.properties.bearing) ? [e.properties.bearing[0], e.properties.bearing[1]] : void 0) : (console.warn(
      "The `waypointsBearings` getter was referred to, but the `bearings` configuration option is not enabled!"
    ), []);
  }
  /**
   * Sets the waypoints' bearings values. Does not produce any effect in case the `bearings` configuration option is
   * disabled.
   */
  set waypointsBearings(e) {
    if (!this.configuration.bearings) {
      console.warn(
        "The `waypointsBearings` setter was referred to, but the `bearings` configuration option is not enabled!"
      );
      return;
    }
    this._waypoints.forEach((r, o) => {
      r.properties.bearing = e[o];
    });
    const n = new z("rotatewaypoints", void 0);
    this.fire(n), this.draw();
    try {
      this.fetchDirections(n);
    } catch {
    }
  }
  /**
   * Replaces all the waypoints with the specified ones and re-fetches the routes.
   *
   * @param waypoints The coordinates at which the waypoints should be added
   * @return Resolved after the routing request has finished
   */
  async setWaypoints(e) {
    var r;
    (r = this.abortController) == null || r.abort(), this._waypoints = e.map((o, s) => this.buildPoint(
      o,
      "WAYPOINT",
      this.configuration.bearings ? {
        bearing: this.waypointsBearings[s]
      } : void 0
    )), this.assignWaypointsCategories();
    const n = new z("setwaypoints", void 0);
    this.fire(n), this.draw();
    try {
      await this.fetchDirections(n);
    } catch {
    }
  }
  /**
   * Adds a waypoint at the specified coordinates to the map and re-fetches the routes.
   *
   * @param waypoint The coordinates at which the waypoint should be added
   * @param index The index the waypoint should be inserted at. If omitted, the waypoint is inserted at the end
   * @return Resolved after the routing request has finished
   */
  async addWaypoint(e, n) {
    await this._addWaypoint(e, n);
  }
  /**
   * Removes a waypoint and its related snappoint by the waypoint's index from the map and re-fetches the routes.
   *
   * @param index The index of the waypoint to remove
   * @return Resolved after the routing request has finished
   */
  async removeWaypoint(e) {
    await this._removeWaypoint(e);
  }
  /**
   * Clears the map from all the instance's traces: waypoints, snappoints, routes, etc.
   */
  clear() {
    this.setWaypoints([]), this.routelines = [];
  }
  /**
   * Removes all the added `MapLibreGlDirections`-specific layers and sources. Must be called manually before
   * de-initializing the instance.
   */
  destroy() {
    var e;
    (e = this.abortController) == null || e.abort("DESTROY"), this.clear(), this.interactive = !1, this.configuration.layers.forEach((n) => {
      this.map.removeLayer(n.id);
    }), this.map.removeSource(this.configuration.sourceName);
  }
}
function W() {
}
function we(t) {
  return t();
}
function le() {
  return /* @__PURE__ */ Object.create(null);
}
function J(t) {
  t.forEach(we);
}
function De(t) {
  return typeof t == "function";
}
function Ee(t, i) {
  return t != t ? i == i : t !== i || t && typeof t == "object" || typeof t == "function";
}
function Ae(t) {
  return Object.keys(t).length === 0;
}
function _(t, i) {
  t.appendChild(i);
}
function k(t, i, e) {
  t.insertBefore(i, e || null);
}
function O(t) {
  t.parentNode && t.parentNode.removeChild(t);
}
function ze(t, i) {
  for (let e = 0; e < t.length; e += 1)
    t[e] && t[e].d(i);
}
function M(t) {
  return document.createElement(t);
}
function I(t) {
  return document.createElementNS("http://www.w3.org/2000/svg", t);
}
function X(t) {
  return document.createTextNode(t);
}
function x() {
  return X(" ");
}
function Ne() {
  return X("");
}
function V(t, i, e, n) {
  return t.addEventListener(i, e, n), () => t.removeEventListener(i, e, n);
}
function h(t, i, e) {
  e == null ? t.removeAttribute(i) : t.getAttribute(i) !== e && t.setAttribute(i, e);
}
function K(t) {
  return t === "" ? null : +t;
}
function $e(t) {
  return Array.from(t.childNodes);
}
function je(t, i) {
  i = "" + i, t.data !== i && (t.data = /** @type {string} */
  i);
}
function Q(t, i) {
  t.value = i ?? "";
}
function B(t, i, e, n) {
  e == null ? t.style.removeProperty(i) : t.style.setProperty(i, e, n ? "important" : "");
}
let G;
function U(t) {
  G = t;
}
function qe() {
  if (!G)
    throw new Error("Function called outside component initialization");
  return G;
}
function Ue(t) {
  qe().$$.on_destroy.push(t);
}
const $ = [], F = [];
let j = [];
const he = [], Ge = /* @__PURE__ */ Promise.resolve();
let ee = !1;
function Je() {
  ee || (ee = !0, Ge.then(Le));
}
function te(t) {
  j.push(t);
}
const Z = /* @__PURE__ */ new Set();
let N = 0;
function Le() {
  if (N !== 0)
    return;
  const t = G;
  do {
    try {
      for (; N < $.length; ) {
        const i = $[N];
        N++, U(i), Ye(i.$$);
      }
    } catch (i) {
      throw $.length = 0, N = 0, i;
    }
    for (U(null), $.length = 0, N = 0; F.length; )
      F.pop()();
    for (let i = 0; i < j.length; i += 1) {
      const e = j[i];
      Z.has(e) || (Z.add(e), e());
    }
    j.length = 0;
  } while ($.length);
  for (; he.length; )
    he.pop()();
  ee = !1, Z.clear(), U(t);
}
function Ye(t) {
  if (t.fragment !== null) {
    t.update(), J(t.before_update);
    const i = t.dirty;
    t.dirty = [-1], t.fragment && t.fragment.p(t.ctx, i), t.after_update.forEach(te);
  }
}
function Ve(t) {
  const i = [], e = [];
  j.forEach((n) => t.indexOf(n) === -1 ? i.push(n) : e.push(n)), e.forEach((n) => n()), j = i;
}
const Xe = /* @__PURE__ */ new Set();
function Ke(t, i) {
  t && t.i && (Xe.delete(t), t.i(i));
}
function pe(t) {
  return (t == null ? void 0 : t.length) !== void 0 ? t : Array.from(t);
}
function Qe(t, i, e) {
  const { fragment: n, after_update: r } = t.$$;
  n && n.m(i, e), te(() => {
    const o = t.$$.on_mount.map(we).filter(De);
    t.$$.on_destroy ? t.$$.on_destroy.push(...o) : J(o), t.$$.on_mount = [];
  }), r.forEach(te);
}
function Ze(t, i) {
  const e = t.$$;
  e.fragment !== null && (Ve(e.after_update), J(e.on_destroy), e.fragment && e.fragment.d(i), e.on_destroy = e.fragment = null, e.ctx = []);
}
function Fe(t, i) {
  t.$$.dirty[0] === -1 && ($.push(t), Je(), t.$$.dirty.fill(0)), t.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function Me(t, i, e, n, r, o, s, a = [-1]) {
  const l = G;
  U(t);
  const d = t.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: o,
    update: W,
    not_equal: r,
    bound: le(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(i.context || (l ? l.$$.context : [])),
    // everything else
    callbacks: le(),
    dirty: a,
    skip_bound: !1,
    root: i.target || l.$$.root
  };
  s && s(d.root);
  let c = !1;
  if (d.ctx = e ? e(t, i.props || {}, (p, g, ...m) => {
    const f = m.length ? m[0] : g;
    return d.ctx && r(d.ctx[p], d.ctx[p] = f) && (!d.skip_bound && d.bound[p] && d.bound[p](f), c && Fe(t, p)), g;
  }) : [], d.update(), c = !0, J(d.before_update), d.fragment = n ? n(d.ctx) : !1, i.target) {
    if (i.hydrate) {
      const p = $e(i.target);
      d.fragment && d.fragment.l(p), p.forEach(O);
    } else
      d.fragment && d.fragment.c();
    i.intro && Ke(t.$$.fragment), Qe(t, i.target, i.anchor), Le();
  }
  U(l);
}
class Ie {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    u(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    u(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    Ze(this, 1), this.$destroy = W;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(i, e) {
    if (!De(e))
      return W;
    const n = this.$$.callbacks[i] || (this.$$.callbacks[i] = []);
    return n.push(e), () => {
      const r = n.indexOf(e);
      r !== -1 && n.splice(r, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(i) {
    this.$$set && !Ae(i) && (this.$$.skip_bound = !0, this.$$set(i), this.$$.skip_bound = !1);
  }
}
const et = "4";
typeof window < "u" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(et);
function de(t) {
  let i, e, n, r, o, s, a, l, d, c, p, g, m, f, D, E;
  return {
    c() {
      i = I("svg"), e = I("circle"), r = I("path"), s = I("g"), a = I("path"), d = I("path"), p = I("path"), m = I("animateTransform"), h(e, "cx", "64.13"), h(e, "cy", "64.13"), h(e, "r", "27.63"), h(e, "fill", n = /*configuration*/
      t[0].fill), h(r, "d", "M64.13 18.5A45.63 45.63 0 1 1 18.5 64.13 45.63 45.63 0 0 1 64.13 18.5zm0 7.85a37.78 37.78 0 1 1-37.78 37.78 37.78 37.78 0 0 1 37.78-37.78z"), h(r, "fill-rule", "evenodd"), h(r, "fill", o = /*configuration*/
      t[0].fill), h(a, "d", "M95.25 17.4a56.26 56.26 0 0 0-76.8 13.23L12.1 26.2a64 64 0 0 1 87.6-15.17z"), h(a, "fill", l = /*configuration*/
      t[0].fill), h(d, "d", "M95.25 17.4a56.26 56.26 0 0 0-76.8 13.23L12.1 26.2a64 64 0 0 1 87.6-15.17z"), h(d, "fill", c = /*configuration*/
      t[0].fill), h(d, "transform", "rotate(120 64 64)"), h(p, "d", "M95.25 17.4a56.26 56.26 0 0 0-76.8 13.23L12.1 26.2a64 64 0 0 1 87.6-15.17z"), h(p, "fill", g = /*configuration*/
      t[0].fill), h(p, "transform", "rotate(240 64 64)"), h(m, "attributeName", "transform"), h(m, "type", "rotate"), h(m, "from", "0 64 64"), h(m, "to", "120 64 64"), h(m, "dur", "360ms"), h(m, "repeatCount", "indefinite"), h(i, "xmlns", "http://www.w3.org/2000/svg"), h(i, "width", f = /*configuration*/
      t[0].size), h(i, "height", D = /*configuration*/
      t[0].size), h(i, "viewBox", "0 0 128 128"), h(i, "xml:space", "preserve"), h(i, "class", E = /*configuration*/
      t[0].class);
    },
    m(w, v) {
      k(w, i, v), _(i, e), _(i, r), _(i, s), _(s, a), _(s, d), _(s, p), _(s, m);
    },
    p(w, v) {
      v & /*configuration*/
      1 && n !== (n = /*configuration*/
      w[0].fill) && h(e, "fill", n), v & /*configuration*/
      1 && o !== (o = /*configuration*/
      w[0].fill) && h(r, "fill", o), v & /*configuration*/
      1 && l !== (l = /*configuration*/
      w[0].fill) && h(a, "fill", l), v & /*configuration*/
      1 && c !== (c = /*configuration*/
      w[0].fill) && h(d, "fill", c), v & /*configuration*/
      1 && g !== (g = /*configuration*/
      w[0].fill) && h(p, "fill", g), v & /*configuration*/
      1 && f !== (f = /*configuration*/
      w[0].size) && h(i, "width", f), v & /*configuration*/
      1 && D !== (D = /*configuration*/
      w[0].size) && h(i, "height", D), v & /*configuration*/
      1 && E !== (E = /*configuration*/
      w[0].class) && h(i, "class", E);
    },
    d(w) {
      w && O(i);
    }
  };
}
function tt(t) {
  let i, e = (
    /*loading*/
    t[1] && de(t)
  );
  return {
    c() {
      e && e.c(), i = Ne();
    },
    m(n, r) {
      e && e.m(n, r), k(n, i, r);
    },
    p(n, [r]) {
      /*loading*/
      n[1] ? e ? e.p(n, r) : (e = de(n), e.c(), e.m(i.parentNode, i)) : e && (e.d(1), e = null);
    },
    i: W,
    o: W,
    d(n) {
      n && O(i), e && e.d(n);
    }
  };
}
function it(t, i, e) {
  let { directions: n } = i, { configuration: r } = i, o;
  return n.on("fetchroutesstart", () => {
    e(1, o = !0);
  }), n.on("fetchroutesend", () => {
    e(1, o = !1);
  }), t.$$set = (s) => {
    "directions" in s && e(2, n = s.directions), "configuration" in s && e(0, r = s.configuration);
  }, [r, o, n];
}
class nt extends Ie {
  constructor(i) {
    super(), Me(this, i, it, tt, Ee, { directions: 2, configuration: 0 });
  }
}
const ot = {
  fill: "#6d26d7",
  size: "24px",
  class: ""
};
class ut {
  constructor(i, e) {
    u(this, "controlElement");
    u(this, "directions");
    u(this, "configuration");
    this.directions = i, this.configuration = Object.assign({}, ot, e);
  }
  /**
   * @private
   */
  onAdd() {
    return this.controlElement = document.createElement("div"), new nt({
      target: this.controlElement,
      props: {
        directions: this.directions,
        configuration: this.configuration
      }
    }), this.controlElement;
  }
  /**
   * @private
   */
  onRemove() {
    this.controlElement.remove();
  }
}
function ce(t, i, e) {
  const n = t.slice();
  return n[16] = i[e], n[17] = i, n[18] = e, n;
}
function st(t) {
  let i, e, n, r, o, s, a, l, d;
  function c() {
    t[11].call(
      i,
      /*each_value*/
      t[17],
      /*i*/
      t[18]
    );
  }
  return {
    c() {
      i = M("input"), s = x(), a = M("span"), a.textContent = "°", h(i, "type", "number"), i.disabled = e = !/*waypointBearing*/
      t[16].enabled, h(i, "min", n = /*configuration*/
      t[0].degreesMin), h(i, "max", r = /*configuration*/
      t[0].degreesMax), h(i, "step", o = /*configuration*/
      t[0].degreesStep), h(i, "class", "maplibre-gl-directions-bearings-control__input"), h(a, "class", "maplibre-gl-directions-bearings-control__text");
    },
    m(p, g) {
      k(p, i, g), Q(
        i,
        /*waypointBearing*/
        t[16].degrees
      ), k(p, s, g), k(p, a, g), l || (d = V(i, "input", c), l = !0);
    },
    p(p, g) {
      t = p, g & /*waypointsBearings*/
      2 && e !== (e = !/*waypointBearing*/
      t[16].enabled) && (i.disabled = e), g & /*configuration*/
      1 && n !== (n = /*configuration*/
      t[0].degreesMin) && h(i, "min", n), g & /*configuration*/
      1 && r !== (r = /*configuration*/
      t[0].degreesMax) && h(i, "max", r), g & /*configuration*/
      1 && o !== (o = /*configuration*/
      t[0].degreesStep) && h(i, "step", o), g & /*waypointsBearings*/
      2 && K(i.value) !== /*waypointBearing*/
      t[16].degrees && Q(
        i,
        /*waypointBearing*/
        t[16].degrees
      );
    },
    d(p) {
      p && (O(i), O(s), O(a)), l = !1, d();
    }
  };
}
function rt(t) {
  let i, e = (
    /*configuration*/
    t[0].fixedDegrees + ""
  ), n, r;
  return {
    c() {
      i = M("span"), n = X(e), r = X("°"), h(i, "class", "maplibre-gl-directions-bearings-control__text");
    },
    m(o, s) {
      k(o, i, s), _(i, n), _(i, r);
    },
    p(o, s) {
      s & /*configuration*/
      1 && e !== (e = /*configuration*/
      o[0].fixedDegrees + "") && je(n, e);
    },
    d(o) {
      o && O(i);
    }
  };
}
function ge(t) {
  let i, e, n, r, o, s, a, l, d, c, p, g = (
    /*i*/
    t[18]
  ), m, f, D, E, w, v, y, b, P, T, A, H, S, q, ie;
  function Pe() {
    t[7].call(
      r,
      /*each_value*/
      t[17],
      /*i*/
      t[18]
    );
  }
  const ne = () => (
    /*div0_binding*/
    t[8](s, g)
  ), oe = () => (
    /*div0_binding*/
    t[8](null, g)
  );
  function Ce(...R) {
    return (
      /*mousedown_handler*/
      t[9](
        /*i*/
        t[18],
        ...R
      )
    );
  }
  function Te() {
    t[10].call(
      f,
      /*each_value*/
      t[17],
      /*i*/
      t[18]
    );
  }
  function se(R, L) {
    return (
      /*configuration*/
      R[0].fixedDegrees ? rt : st
    );
  }
  let Y = se(t), C = Y(t);
  return {
    c() {
      i = M("div"), e = M("span"), e.textContent = `${/*i*/
      t[18] + 1}.`, n = x(), r = M("input"), o = x(), s = M("div"), a = I("svg"), l = I("circle"), p = I("circle"), m = x(), f = M("input"), y = x(), b = M("span"), b.textContent = "°", P = x(), T = M("span"), T.textContent = "±", A = x(), C.c(), H = x(), h(e, "class", "maplibre-gl-directions-bearings-control__number text-slate-800"), h(r, "type", "checkbox"), h(r, "class", "maplibre-gl-directions-bearings-control__checkbox"), h(l, "r", "5"), h(l, "cx", "10"), h(l, "cy", "10"), h(l, "fill", "transparent"), h(l, "stroke", "rgba(109, 38, 215, 0.65)"), h(l, "stroke-width", "10"), h(l, "stroke-dasharray", d = /*waypointBearing*/
      t[16].degrees / 3.6 * 31.42 / 100 + " 31.42"), h(l, "transform", c = "rotate(" + (-90 - /*waypointBearing*/
      t[16].degrees / 2 + /*waypointBearing*/
      t[16].angle - /*angleAdjustment*/
      t[3]) + ")"), B(l, "transform-origin", "10px 10px"), h(p, "r", "6"), h(p, "cx", "10"), h(p, "cy", "10"), h(p, "fill", "rgb(109, 38, 215)"), h(a, "height", "20"), h(a, "width", "20"), h(a, "viewBox", "0 0 20 20"), h(a, "class", "maplibre-gl-directions-bearings-control__waypoint-image"), B(
        a,
        "width",
        /*configuration*/
        t[0].imageSize + "px"
      ), B(
        a,
        "height",
        /*configuration*/
        t[0].imageSize + "px"
      ), B(
        a,
        "opacity",
        /*waypointBearing*/
        t[16].enabled ? 1 : 0.25
      ), h(s, "role", "spinbutton"), h(s, "tabindex", "0"), h(f, "type", "number"), f.disabled = D = !/*waypointBearing*/
      t[16].enabled, h(f, "min", E = /*configuration*/
      t[0].angleMin), h(f, "max", w = /*configuration*/
      t[0].angleMax), h(f, "step", v = /*configuration*/
      t[0].angleStep), h(f, "class", "maplibre-gl-directions-bearings-control__input"), h(b, "class", "maplibre-gl-directions-bearings-control__text"), h(T, "class", "maplibre-gl-directions-bearings-control__text"), h(i, "class", S = "maplibre-gl-directions-bearings-control__list-item " + /*waypointBearing*/
      (t[16].enabled ? "maplibre-gl-directions-bearings-control__list-item--enabled" : "maplibre-gl-directions-bearings-control__list-item--disabled") + " flex items-center gap-2 text-slate-800" + /*waypointBearing*/
      (t[16].enabled ? "" : "/50"));
    },
    m(R, L) {
      k(R, i, L), _(i, e), _(i, n), _(i, r), r.checked = /*waypointBearing*/
      t[16].enabled, _(i, o), _(i, s), _(s, a), _(a, l), _(a, p), ne(), _(i, m), _(i, f), Q(
        f,
        /*waypointBearing*/
        t[16].angle
      ), _(i, y), _(i, b), _(i, P), _(i, T), _(i, A), C.m(i, null), _(i, H), q || (ie = [
        V(r, "change", Pe),
        V(s, "mousedown", Ce),
        V(f, "input", Te)
      ], q = !0);
    },
    p(R, L) {
      t = R, L & /*waypointsBearings*/
      2 && (r.checked = /*waypointBearing*/
      t[16].enabled), L & /*waypointsBearings*/
      2 && d !== (d = /*waypointBearing*/
      t[16].degrees / 3.6 * 31.42 / 100 + " 31.42") && h(l, "stroke-dasharray", d), L & /*waypointsBearings, angleAdjustment*/
      10 && c !== (c = "rotate(" + (-90 - /*waypointBearing*/
      t[16].degrees / 2 + /*waypointBearing*/
      t[16].angle - /*angleAdjustment*/
      t[3]) + ")") && h(l, "transform", c), L & /*configuration*/
      1 && B(
        a,
        "width",
        /*configuration*/
        t[0].imageSize + "px"
      ), L & /*configuration*/
      1 && B(
        a,
        "height",
        /*configuration*/
        t[0].imageSize + "px"
      ), L & /*waypointsBearings*/
      2 && B(
        a,
        "opacity",
        /*waypointBearing*/
        t[16].enabled ? 1 : 0.25
      ), g !== /*i*/
      t[18] && (oe(), g = /*i*/
      t[18], ne()), L & /*waypointsBearings*/
      2 && D !== (D = !/*waypointBearing*/
      t[16].enabled) && (f.disabled = D), L & /*configuration*/
      1 && E !== (E = /*configuration*/
      t[0].angleMin) && h(f, "min", E), L & /*configuration*/
      1 && w !== (w = /*configuration*/
      t[0].angleMax) && h(f, "max", w), L & /*configuration*/
      1 && v !== (v = /*configuration*/
      t[0].angleStep) && h(f, "step", v), L & /*waypointsBearings*/
      2 && K(f.value) !== /*waypointBearing*/
      t[16].angle && Q(
        f,
        /*waypointBearing*/
        t[16].angle
      ), Y === (Y = se(t)) && C ? C.p(t, L) : (C.d(1), C = Y(t), C && (C.c(), C.m(i, H))), L & /*waypointsBearings*/
      2 && S !== (S = "maplibre-gl-directions-bearings-control__list-item " + /*waypointBearing*/
      (t[16].enabled ? "maplibre-gl-directions-bearings-control__list-item--enabled" : "maplibre-gl-directions-bearings-control__list-item--disabled") + " flex items-center gap-2 text-slate-800" + /*waypointBearing*/
      (t[16].enabled ? "" : "/50")) && h(i, "class", S);
    },
    d(R) {
      R && O(i), oe(), C.d(), q = !1, J(ie);
    }
  };
}
function at(t) {
  let i, e, n, r = pe(
    /*waypointsBearings*/
    t[1]
  ), o = [];
  for (let s = 0; s < r.length; s += 1)
    o[s] = ge(ce(t, r, s));
  return {
    c() {
      i = M("div"), e = M("div");
      for (let s = 0; s < o.length; s += 1)
        o[s].c();
      h(e, "class", "maplibre-gl-directions-bearings-control__list flex flex-col max-h-96 overflow-y-auto"), h(i, "class", n = "maplibre-gl-directions-bearings-control maplibregl-ctrl maplibregl-ctrl-group p-4 " + /*waypointsBearings*/
      (t[1].length ? "block" : "hidden") + " bg-white text-base rounded");
    },
    m(s, a) {
      k(s, i, a), _(i, e);
      for (let l = 0; l < o.length; l += 1)
        o[l] && o[l].m(e, null);
    },
    p(s, [a]) {
      if (a & /*waypointsBearings, configuration, images, onImageMousedown, angleAdjustment*/
      31) {
        r = pe(
          /*waypointsBearings*/
          s[1]
        );
        let l;
        for (l = 0; l < r.length; l += 1) {
          const d = ce(s, r, l);
          o[l] ? o[l].p(d, a) : (o[l] = ge(d), o[l].c(), o[l].m(e, null));
        }
        for (; l < o.length; l += 1)
          o[l].d(1);
        o.length = r.length;
      }
      a & /*waypointsBearings*/
      2 && n !== (n = "maplibre-gl-directions-bearings-control maplibregl-ctrl maplibregl-ctrl-group p-4 " + /*waypointsBearings*/
      (s[1].length ? "block" : "hidden") + " bg-white text-base rounded") && h(i, "class", n);
    },
    i: W,
    o: W,
    d(s) {
      s && O(i), ze(o, s);
    }
  };
}
function lt(t, i, e) {
  let { directions: n } = i, { configuration: r } = i;
  n.configuration.bearings || console.warn("The Bearings Control is used, but the `bearings` configuration option is not enabled!");
  let o = [];
  n.on("addwaypoint", s), n.on("removewaypoint", s), n.on("movewaypoint", s), n.on("setwaypoints", s);
  function s() {
    e(1, o = n.waypointsBearings.map((y, b) => o[b] ? o[b] : {
      enabled: r.defaultEnabled || !!y,
      angle: y ? y[0] : r.angleDefault,
      degrees: y ? y[1] : r.fixedDegrees ? r.fixedDegrees : r.degreesDefault
    }));
  }
  s();
  let a;
  const l = [];
  let d = -1;
  function c(y, b) {
    var P;
    (P = o[b]) != null && P.enabled && (d = b, document.addEventListener("mouseup", p), document.addEventListener("mousemove", g));
  }
  function p() {
    d = -1, document.removeEventListener("mouseup", p), document.removeEventListener("mousemove", g);
  }
  function g(y) {
    if (~d && l[d]) {
      const b = l[d], P = b.getBoundingClientRect().x + r.imageSize / 2, T = b.getBoundingClientRect().y + r.imageSize / 2, A = y.pageX, H = y.pageY, q = Math.atan2(A - P, H - T) * (180 / Math.PI) * -1 + 90;
      e(1, o[d].angle = 90 + q + m | 0, o);
    }
  }
  Ue(() => {
    document.removeEventListener("mouseup", p), document.removeEventListener("mousemove", g);
  });
  let m = 0;
  r.respectMapBearing && n.map.on("rotate", () => e(3, m = n.map.getBearing()));
  function f(y, b) {
    y[b].enabled = this.checked, e(1, o);
  }
  function D(y, b) {
    F[y ? "unshift" : "push"](() => {
      l[b] = y, e(2, l);
    });
  }
  const E = (y, b) => c(b, y);
  function w(y, b) {
    y[b].angle = K(this.value), e(1, o);
  }
  function v(y, b) {
    y[b].degrees = K(this.value), e(1, o);
  }
  return t.$$set = (y) => {
    "directions" in y && e(5, n = y.directions), "configuration" in y && e(0, r = y.configuration);
  }, t.$$.update = () => {
    t.$$.dirty & /*timeout, waypointsBearings, configuration*/
    67 && (a && clearTimeout(a), e(6, a = setTimeout(
      () => {
        e(
          5,
          n.waypointsBearings = o.map((y) => y.enabled ? [y.angle, y.degrees] : void 0),
          n
        );
      },
      r.debounceTimeout
    )));
  }, [
    r,
    o,
    l,
    m,
    c,
    n,
    a,
    f,
    D,
    E,
    w,
    v
  ];
}
let ht = class extends Ie {
  constructor(i) {
    super(), Me(this, i, lt, at, Ee, { directions: 5, configuration: 0 });
  }
};
const pt = {
  defaultEnabled: !1,
  debounceTimeout: 150,
  angleDefault: 0,
  angleMin: 0,
  angleMax: 359,
  angleStep: 1,
  fixedDegrees: 0,
  degreesDefault: 45,
  degreesMin: 15,
  degreesMax: 360,
  degreesStep: 15,
  respectMapBearing: !1,
  imageSize: 50
};
class mt {
  constructor(i, e) {
    u(this, "controlElement");
    u(this, "directions");
    u(this, "configuration");
    this.directions = i, this.configuration = Object.assign({}, pt, e);
  }
  /**
   * @private
   */
  onAdd() {
    return this.controlElement = document.createElement("div"), new ht({
      target: this.controlElement,
      props: {
        directions: this.directions,
        configuration: this.configuration
      }
    }), this.controlElement;
  }
  /**
   * @private
   */
  onRemove() {
    this.controlElement.remove();
  }
}
export {
  mt as BearingsControl,
  ut as LoadingIndicatorControl,
  re as MapLibreGlDirectionsRoutingEvent,
  z as MapLibreGlDirectionsWaypointEvent,
  gt as default,
  ke as layersFactory,
  ct as utils
};
//# sourceMappingURL=maplibre-gl-directions.js.map
